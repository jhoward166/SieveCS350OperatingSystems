1) I WAY ovecomplicated getting the child processes work. I was trying to get them to never attempt the same prime twice. Big mistake. It caused me a lot of headaches and cost me time trying to construct an algorithm that would search to see if the prime had been hit then keep the primes in order. Last night was spent trying to wrestle with semaphores. Today in lab Mike told me I could just knock all of the numbers out, and then use my parent to review the shared memory after the children were done. SO MUCH EASIER. I also had a very annoying problem when creating memory. I would get a "Bus Error" message for any size over 4 digits. This was kind of a weird problem and I have no idea why it was happening, but I switched shm_open() to open() and it worked. Thank you Mike and Stephanie for helping me figure that out. I was having a hard time with that when I was testing.

2)I actually used the structure of the binary tree to pass children a unique id. Each process is given a process id that represents it's place in the tree and the bottom level is then given a worker id in the range of 1-worker number. Then those processes with a pid of 0 execute and remove their specific prime from a list of the first 16 based on their worker number.

3)When the worker passes the size parameter it looks for the next item in shared memory that is 0. The index of that position is the new prime. It is entirely possible for 2 workers or even more to be using the same prime simultaneously because we never rule out primes that we have already used. Processes that fall behind may pick up that prime as its prime on its next rotation through memory. This means that extra work is being done.
